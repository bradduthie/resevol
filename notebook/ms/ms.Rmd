---
title: 'resevol: an R package for spatially explicit models of pesticide resistance
  given evolving pest genomes'
author: |
  | A. Bradley Duthie&#xb9;&#xb2;, et al.
date: '[1] Biological and Environmental Sciences, University of Stirling, Stirling,
  UK [2]  alexander.duthie@stir.ac.uk, Biological and Environmental Sciences 3A149
  University of Stirling Stirling, FK9 4LA, UK'
output:
  bookdown::pdf_document2:
    citation_package: natbib
    fig_caption: yes
    toc: no
  pdf_document:
    toc: no
  html_document: default
  word_document: default
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead[R]{RESEVOL, AN R PACKAGE}
- \usepackage{lineno}
- \linenumbers
- \modulolinenumbers[2]
linestretch: 1
link-citations: yes
linkcolor: blue
bibliography: resevol.bib
biblio-style: apalike
---

******************************

<!---

1. Software: new packages or significant updates in functionality - significant is defined as “novel capabilities enabling new applications”, as opposed to refinements on existing functionalities.

2. At a minimum, everything the reader will need to install and run the software; this includes a URL to see the source in an anonymous way (no login required), a specification of the language(s) used and their version(s), and dependencies on binaries that are not bundled with the software itself nor handled by the language package manager.

3.  Although we do not wish to be prescriptive about the structure, we recommend that the paper includes the application description along with one or several worked examples. Please note that the typical introduction, methods, results, discussion structure isn’t required, and often is not appropriate, for Applications papers.

4. Style guide for R: http://adv-r.had.co.nz/Style.html


--->


Abstract {-}
===================================================

1. Pesticide resistance is a serious problem.
2. We introduce the resevol R package, which runs individual-based models of pests with quantitative and covarying traits and three mating systems.
3. Simulations are on a landscape where crops and pesticides are changed.
4. We give an example of simulating pests with covarying traits
5. The resevol R package is open source under GNU Public License; source code and documents are freely available on GitHub.

**Key words:** *pest management*, *food security*, *ecological modelling*

Introduction {#introduction}
===================================================

- Pest resistance to pesticide is a serious wicked problem that affects food security (I have some references for this, but am probably missing several).
- A quantitative genetic approach to pesticide resistance to maintaining resistance (has this been done at all?).


```{r, echo = FALSE}
library("resevol");
```


The resevol package uses individual-based modelling and a quantitative genetics approach to simulate the evolution of a pest population on a changing landscape. 
A focal goal of the software is to model traits with a pre-specified, but potentially evolving, covariance structure. 
To achieve this goal, each individual has a genome with $L$ loci that underlie a set of $T$ potentially evolving traits. 
Pleiotropic loci can vary in their effects on the direction and magnitude of polygenic trait, causing population-wide trait covariance to arise mechanistically from the underlying genetic architecture of individuals. 
To achieve this, two separate steps are necessary.
First, a genetic algorithm is used to find a network of internal nodes that map standard random normal loci values to covarying traits.
Values used to map loci to traits are incorporated into individual genomes.
Second, a population of asexual or sexual individuals is initialised and simulated on a spatially explicit landscape separated into distinct units (e.g., farms).
Land units can apply one of up to 10 pesticides, and one of up to 10 crops; pesticides and crops rotate independently in a pre-specified way over time.
The resevol package can thereby model complex and evolving traits in agricultural pests over realistic landscapes that undergo different pesticide use and crop regimes.

Covarying pest quantitative traits {#mine_gmatrix}
===================================================

The first step of simulation with the resevol package is building individual genomes. 
This step is separate because building genomes is often time-consuming, and genomes that are built might need to be saved or inspected before actual simulation.
High computation time is due to the mechanistic nature of how genomes and covarying traits are modelled.
Instead of imposing a trait covariance structure directly, the objective is to use an evolutionary algorithm to find a network that maps standard random normal values (loci) to covarying values (traits).
This is useful because it allows genomes to model potentially evolving physiological constraints, and trade-offs among traits, from the bottom up.
Since multiple networks can potentially map loci to the same trait covariance structure, it is possible to replicate evolution with differently randomised genetic architectures.
This approach to modelling individual genomes and traits thereby increases the complexity of questions that can be addressed for simulating evolution in agricultural pests.

```{r network, echo = FALSE, fig.width = 6, fig.height = 4, fig.cap = "Example network mapping loci (green circles) to traits (red diamonds) through an intermediate set of hidden layers (blue squares) in the mine_gmatrix function. Individual genomes in the resevol R package consist of standard random normal values for at loci, real values for black arrows linking nodes, and real values of traits. Values shown for loci and arrows are an example for illustration."}
par(mar = c(0.2, 0.2, 0, 0.2));
plot(x = 0, y = 0, type = "n", xlim = c(0, 1000), ylim = c(0, 1000), 
     xaxt = "n", yaxt = "n", bty = "n", xlab = "", ylab = "");
mtext(side = 1, text = "Internal nodes", cex = 1.25, col = "blue", line = -3);
mtext(side = 2, text = "Loci", cex = 1.25, col = "darkgreen", line = -2);
mtext(side = 4, text = "Traits", cex = 1.25, col = "red", line = -2);
Lx  <- rep(x = 100, times = 3);
Ly  <- seq(from = 250, to = 750, length = 3);
H1x <- rep(x = 400, times = 2);
H1y <- seq(from = 250, to = 750, length = 2);
H2x <- rep(x = 600, times = 2);
H2y <- seq(from = 250, to = 750, length = 2);
Tx  <- rep(x = 900, times = 2);
Ty  <- seq(from = 250, to = 750, length = 2);
points(x = Tx, y = Ty, pch = 23, cex = 8, bg = "red", lwd = 2);
sep_L_points <- c(-50, 0, 50);
sep_N_points <- c(-30, 30);
arrows(x0 = H2x + 52, x1 = Tx[1] - 58, y0 = H2y, y1 = Ty[1] + sep_N_points, 
       length = 0.08, lwd = 3);
arrows(x0 = H2x + 52, x1 = Tx[2] - 58, y0 = H2y, y1 = Ty[2] + sep_N_points, 
       length = 0.08, lwd = 3);
arrows(x0 = Lx + 38, x1 = H1x[1] - 58, y0 = Ly, y1 = H1y[1] + sep_L_points, 
       length = 0.08, lwd = 3);
points(x = H2x, y = H2y, pch = 22, cex = 9, bg = "blue", lwd = 2);
arrows(x0 = H1x + 52, x1 = H2x[1] - 58, y0 = H1y, y1 = H2y[1] + sep_N_points, 
       length = 0.08, lwd = 3);
arrows(x0 = H1x + 52, x1 = H2x[2] - 58, y0 = H1y, y1 = H2y[2] + sep_N_points, 
       length = 0.08, lwd = 3);
points(x = H1x, y = H1y, pch = 22, cex = 9, bg = "blue", lwd = 2);
arrows(x0 = Lx + 38, x1 = H1x[2] - 58, y0 = Ly, y1 = H1y[2] + sep_L_points, 
       length = 0.08, lwd = 3);
points(x = Lx, y = Ly, pch = 21, cex = 6, bg = "darkgreen", lwd = 2);
srnm <- c(0.2, -0.1, 0.1);
text(x = Lx, y = Ly, labels = srnm, col = "white", cex = 0.9);
text(x = 200, y = 790, labels = "0.4", srt = 10, cex = 0.8);
text(x = 200, y = 660, labels = "-1.2", srt = -58, cex = 0.8);
text(x = 270, y = 695, labels = "0.2", srt = 46, cex = 0.8);
text(x = 180, y = 480, labels = "0.1", srt = -40, cex = 0.8);
text(x = 160, y = 340, labels = "-0.6", srt = 54, cex = 0.8);
text(x = 220, y = 255, labels = "2.2", srt = -12, cex = 0.8);
text(x = 490, y = 790, labels = "1.3", srt = 10, cex = 0.8);
text(x = 538, y = 410, labels = "-0.5", srt = -76, cex = 0.8);
text(x = 460, y = 390, labels = "-0.1", srt = 72, cex = 0.8);
text(x = 495, y = 260, labels = "0.0", srt = -12, cex = 0.8);
text(x = 720, y = 790, labels = "2.2", srt = 8, cex = 0.8);
text(x = 720, y = 630, labels = "0.9", srt = -58, cex = 0.8);
text(x = 690, y = 400, labels = "1.6", srt = 54, cex = 0.8);
text(x = 740, y = 260, labels = "0.8", srt = -8, cex = 0.8);
Loci  <- matrix(data = c(0.1, -0.1, 0.2), nrow = 1);
Hdn1  <- matrix(data = c(0.4, -1.2, 0.2, 0.1, -0.6, 2.2), nrow = 3, ncol = 2);
Hdn2  <- matrix(data = c(1.3, -0.1, -0.5, 0.0), nrow = 2, ncol = 2);
Hdn3  <- matrix(data = c(2.2, 1.6, 0.9, 0.8), nrow = 2, ncol = 2);
Tvals <- Loci %*% Hdn1 %*% Hdn2 %*% Hdn3;
text(x = Tx, y = Ty, labels = rev(Tvals), cex = 0.8);
```

Conceptually, the relationship between individual genotypes and traits is defined by a network connecting loci to traits through a set of hidden internal nodes (Figure \@ref(fig:network)). 
Values for loci are randomly drawn from a standard normal distribution $\mathcal{N}\left(0, 1\right)$. 
Links between loci, internal nodes, and traits, can take any real value and are represented by black arrows in Figure \@ref(fig:network). 
Traits can take any real value, and are calculated as the summed effects of all preceding nodes (i.e., the blue squares immediately to the left of the traits in Figure \@ref(fig:network)).
Mathematically, loci are represented by row a vector of length $L$.
Effects of loci on the first layer of internal nodes (black arrows emanating from loci in Figure \@ref(fig:network)) are represented by an $L \times T$ matrix, and transitions between internal nodes, and between the last set of internal nodes and the final traits, are represented by $T \times T$ matrices.
For the example in Figure \@ref(fig:network), 

$$
\begin{pmatrix}
  0.1, & -0.1, & 0.2 \\
\end{pmatrix} 
\begin{pmatrix}
  0.4, &  0.1 \\
 -1.2, & -0.6 \\
  0.2, &  2.2 \\
\end{pmatrix}
\begin{pmatrix}
   1.3, & -0.5 \\
  -0.1  &  0.0 \\
\end{pmatrix}
\begin{pmatrix}
   2.2, &  0.9 \\
   1.6  &  0.8 \\
\end{pmatrix} = 
\begin{pmatrix}
  0.2998, & 0.1081 \\
\end{pmatrix}.
$$

Values mapping loci to traits become part of an individual's genome, so the genome for the individual represented by Figure \@ref(fig:network) is stored in the model as below:

```
0.1, -0.1, -0.2, 0.4, 0.1, -1.2, -0.6, 0.2, 2.2, 1.3, -0.5, -0.1, 0.0, 2.2, 0.9, 1.6, 0.8
```

Individuals with different loci can therefore have different covarying traits that are constrained by the network structure encoded in each genome. 
Individuals can be haploid (as in Figure \@ref(fig:network)) or diploid (in which case, allele values are summed at a locus). 

An evolutionary algorithm is used to find appropriate values that produce covarying traits from loci (see Supporting Information 1 for details). 
Evolutionary algorithms are heuristic tools can simulate adaptive evolution to find solutions for a broad range of problems [@Hamblin2013; @Duthie2018]. 
In the resevol package, the `mine_gmatrix` function runs an evolutionary algorithm, and requires the argument `gmatrix`, which specifies the desired trait covariance matrix.
The function runs a genetic algorithm that initialises a population of `npsize` networks (Figure \@ref(fig:network)), and this population evolves until some maximum generation number (`max_gen`) or minimum expected network stress (`term_cri`) is met. 
In a single generation of the algorithm, network values crossover and mutate.
Next, trait covariances produced for each network are estimated by initalising `indivs` individuals with loci sampled from a standard normal distribution.
Network stress is calculated as the logged mean squared deviation between estimated covariances and those in `gmatrix`. 
Tournament selection [@Hamblin2013] is then used to determine the networks for the next generation of the algorithm.
Networks with the lowest estimated stress have the highest fitness, so these networks are disproportionately represented in the next generation.
Throughout the evolutionary algorithm, the lowest stress network is saved and output upon network termination.
The robustness of this network's stress to sets of individuals with different loci values can be tested using the `stress_test` function.

An example run of `mine_gmatrix` with the same number of loci and internal nodes is shown below with traits that do not covary:

```{r, eval = FALSE}
trait_covs  <- matrix(data = c(1, -0.4, -0.4, 1), nrow = 2, ncol = 2);
new_network <- mine_gmatrix(loci = 3, layers = 2, gmatrix = trait_covs, 
                            max_gen = 1000, term_cri = -6.0, prnt_out = FALSE);
```


```{r, echo = FALSE}
trait_covs  <- matrix(data = c(1, -0.4, -0.4, 1), nrow = 2, ncol = 2);
load("new_network.rda");
```

The code above found a genome that produced the following expected trait covariances:

```{r, echo = FALSE}
print(new_network[[6]]);
```

The mean deviation between elements of the above matrix and the identity matrix provided by `trait_covs` is `r mean((new_network[[6]] - new_network[[2]])^2)`. 
Lower values of `term_cri` and higher values of `max_gen` will result in a lower stress, but this will require more computation time, especially if the number of traits is high.
Similarly, higher values of `indivs` will result in more accurate estimations of true stress, but this also requires more computation time.
Additional arguments to `mine_gmatrix` can also be used to improve the performance of the evolutionary algorithm (see Supporting Information 1).



Simulating landscape-level pesticide resistance {#simulating}
===================================================

The full output of `mine_gmatrix` is passed to the `run_farm_sim` function, which initialises and simulates an evolving population of pests on a changing landscape for a natural number of time steps (`time_steps`).
In this section, we explain the landscape, pest ecology, and evolving pest traits.

Landscape {#landscape}
---------------------------------------------------

Landscapes are spatially explicit and initialised in `run_farm_sim` in one of two ways. 
First, a landscapes can be built from the arguments `xdim`, `ydim`, and `farms`. 
These arguments specify the dimensions of the landscape and the number of farms on it.
Contiguous rectangular farms of roughly equal size are generated on the landscape using a splitline algorithm.
Second, a custom landscapes can be input using the `terrain` argument, which takes a matrix with elements that includes integers 1 to `farms`.
Each value defines a unique farm, but values do not need to be contiguous.
These 'farms' could even model non-farmland (e.g., water, roads), if pesticides and crops on them are invisible to pests (see below).
This `terrain` customisation therefore allows for a high degree of landscape detail, and offers the potential for modelling real-world landscapes from raster images.
Landscapes are assumed to be a torus, so pests that move off of one edge return on the opposite side of the landscape.

Each farm can hold one pesticide and one crop type at any time step.
The `crop_init` and `pesticide_init` arguments initialise one of `crop_number` crops and one of `pesticide_number` pesticides for each farm, respectively (maximum of 10 each).
Initialisation can be random for each farm with equal probability, or can be set using a vector of length `farms` in which vector elements define the initialised crop or pesticide number.
After initialisation, crops and pesticides rotate once ever `crop_rotation_time` and `pesticide_rotation_time` time steps, respectively.
Each of these rotation time arguments can take either an integer value from 1-3, or a matrix.
Integer values specify (1) no rotation, (2) random transition from one type to another, or (3) cycling through each available crop or pesticide in order.
Square matrices can be used to define the probability that a given crop or pesticide in row $i$ transitions to that in column $j$. 
Hence, any possible Markov chain can be used to transition between crop or pesticide types on farms.


Pest ecology {#ecology}
---------------------------------------------------

Individual pests can be modelled to have several reproductive systems and life histories.
Pest reproductive system can be specified in the `run_farm_sim` function using the `repro` argument, which accepts arguments `"asexual"` (haploid), `"sexual"` (monoecious), and `"biparental"` (dioecious).
For `"sexual"` pests, the `selfing` argument specifies if self-fertilisation is (`TRUE`) or is not (`FALSE`) allowed.
At the start of a simulation, pests are initialised in a random location.
Initialised pests are age of zero if `rand_age = FALSE` or a random age from zero to `max_age` if `rand_age = TRUE`.
Following initialisation, a single time step proceeds with landscape change (see above), pest aging and metabolism, feeding, pesticide consumption, movement, reproduction, mortality, and immigration (Figure \@ref(fig:flowchart)).
Feeding, pesticide consumption, movement, and reproduction all depend on pest age.
Pests feed and consume pesticide from ages `min_age_feed` to `max_age_feed`, move from ages  `min_age_move` to `max_age_move`, and reproduce from ages `min_age_reproduce` to `max_age_reproduce` (all inclusive).
Food accumulated is lost during aging if `baseline_metabolism > 0` and pest age is within `min_age_metabolism` and `max_age_metabolism`.
The option to set minimum and maximum ages for events makes it possible to model pests with much different life histories [e.g., @Sudo2018].

```{r flowchart, echo=FALSE, fig.height=3, fig.width=8, fig.cap = "Overview of simulated events in the resevol R package. Note that metabolism, feeding, pesticide consumption, movement, and reproduction are all subject to a minimum and maximum pest age. Consequently, simulation order might not reflect the order of events from the perspective of a focal pest (e.g., pests might move from ages 1-2, but only feed from ages 2-4). Crops and pesticides are also not necessarily rotated in each time step (see Landscape). Statistics collected within a time step are printed in a CSV file."}
mbox <- function(x0, x1, y0, y1){
    xx <- seq(from=x0, to=x1, length.out = 100);
    yy <- seq(from=y0, to=y1, length.out = 100);
    xd <- c(rep(x0, 100), xx, rep(x1,100), rev(xx));
    yd <- c(yy, rep(y1,100), rev(yy), rep(y0, 100));
    return(list(x=xd, y=yd));
}
par(mar=c(0,0,0,0));
# ===============================================================
plot(x=0, y=0, type="n", xlim=c(0,100), ylim=c(40,95), xaxt="n", yaxt="n",
     xlab="",ylab="");
ibox <- mbox(x0 = 0,  x1 = 14, y0 = 63, y1 = 47);
polygon(x = ibox$x, y = ibox$y, lwd = 5, border = "black", col = "white");
cbox <- mbox(x0 = 0, x1 = 10, y0 = 88, y1 = 72);
polygon(x = cbox$x, y = cbox$y, lwd = 3, border = "black", col = "white");
ubox <- mbox(x0 = 15, x1 = 25, y0 = 88, y1 = 72);
polygon(x = ubox$x, y = ubox$y, lwd = 3, border = "black", col = "white");
nbox <- mbox(x0 = 30, x1 = 40, y0 = 88, y1 = 72);
polygon(x = nbox$x, y = nbox$y, lwd = 3, border = "black", col = "white");
fbox <- mbox(x0 = 45, x1 = 55, y0 = 88, y1 = 72);
polygon(x = fbox$x, y = fbox$y, lwd = 3, border = "black", col = "white");
tbox <- mbox(x0 = 60, x1 = 70, y0 = 88, y1 = 72);
polygon(x = tbox$x, y = tbox$y, lwd = 3, border = "black", col = "white");
tbox <- mbox(x0 = 75, x1 = 85, y0 = 88, y1 = 72);
polygon(x = tbox$x, y = tbox$y, lwd = 3, border = "black", col = "white");
tbox <- mbox(x0 = 90, x1 = 100, y0 = 88, y1 = 72);
polygon(x = tbox$x, y = tbox$y, lwd = 3, border = "black", col = "white");
ibox <- mbox(x0 = 90,  x1 = 100, y0 = 63, y1 = 47);
polygon(x = ibox$x, y = ibox$y, lwd = 3, border = "black", col = "white");
tbox <- mbox(x0 = 75, x1 = 85, y0 = 63, y1 = 47);
polygon(x = tbox$x, y = tbox$y, lwd = 3, border = "black", col = "white");
text(x=7,  y=59, labels="Initialise", col="black", cex = 0.8);
text(x=7,  y=55, labels="pests and", col="black", cex = 0.8);
text(x=7,  y=51, labels="landscape", col="black", cex = 0.8);
text(x=5, y=84, labels="Crops and", col="black", cex = 0.8);
text(x=5, y=80, labels="pesticides", col="black", cex = 0.8);
text(x=5, y=76, labels="rotated?", col="black", cex = 0.8);
text(x=20, y=82, labels="Pests", col="black", cex = 0.8);
text(x=20, y=78, labels="metabolise", col="black", cex = 0.8);
text(x=35, y=82, labels="Pests", col="black", cex = 0.8);
text(x=35, y=78, labels="feed", col="black", cex = 0.8);
text(x=50, y=82, labels="Pesticide", col="black", cex = 0.8);
text(x=50, y=78, labels="consumed", col="black", cex = 0.8);
text(x=65, y=82, labels="Pests", col="black", cex = 0.8);
text(x=65, y=78, labels="move", col="black", cex = 0.8);
text(x=80, y=82, labels="Pests", col="black", cex = 0.8);
text(x=80, y=78, labels="reproduce", col="black", cex = 0.8);
text(x=95, y=82, labels="Pest", col="black", cex = 0.8);
text(x=95, y=78, labels="mortality", col="black", cex = 0.8);
text(x=95,  y=57, labels="Pests", col="black", cex = 0.8);
text(x=95,  y=53, labels="immigrate", col="black", cex = 0.8);
text(x=80,  y=59, labels="Collect", col="black", cex = 0.8);
text(x=80,  y=55, labels="statistics", col="black", cex = 0.8);
text(x=80,  y=51, labels="as CSV", col="black", cex = 0.8);
arrows(x0=2, x1=2,   y0=63, y1=71.5, lwd=2, length=0.10);
arrows(x0=10, x1=14.5, y0=80, y1=80, lwd=2, length=0.10);
arrows(x0=25, x1=29.5, y0=80, y1=80, lwd=2, length=0.10);
arrows(x0=40, x1=44.5, y0=80, y1=80, lwd=2, length=0.10);
arrows(x0=55, x1=59.5, y0=80, y1=80, lwd=2, length=0.10);
arrows(x0=70, x1=74.5, y0=80, y1=80, lwd=2, length=0.10);
arrows(x0=85, x1=89.5, y0=80, y1=80, lwd=2, length=0.10);
arrows(x0=95, x1=95,   y0=72, y1=63.5, lwd=2, length=0.10);
arrows(x0=90, x1=85.5, y0=55, y1=55, lwd=2, length=0.10);
arrows(x0=75, x1=70.5, y0=60, y1=60, lwd=2, length=0.10);
arrows(x0=60, x1=55.5, y0=60, y1=60, lwd=2, length=0.10);
rbox <- mbox(x0 = 60, x1 = 70, y0 = 57, y1 = 63);
polygon(x = rbox$x, y = rbox$y, lwd = 3, border = "black", col = "black");
text(x=65, y=60, labels="Extinction?", col="white", cex = 0.75);
rbox <- mbox(x0 = 45, x1 = 55, y0 = 57, y1 = 63);
polygon(x = rbox$x, y = rbox$y, lwd = 3, border = "black", col = "black");
text(x=50, y=60, labels="Max. time?", col="white", cex = 0.75);
text(x = 58.5, y = 58.5, labels = "No", col = "black", cex = 0.75);
text(x = 43.5, y = 58.5, labels = "No", col = "black", cex = 0.75);
text(x = 68, y = 54, labels = "Yes", col = "black", cex = 0.75);
text(x = 53, y = 54, labels = "Yes", col = "black", cex = 0.75);
arrows(x0=66, x1=66, y0=57, y1=50, lwd=2, length=0.0);
arrows(x0=51, x1=51, y0=57, y1=50, lwd=2, length=0.0);
rbox <- mbox(x0 = 30, x1 = 40, y0 = 47, y1 = 53);
polygon(x = rbox$x, y = rbox$y, lwd = 3, border = "black", col = "black");
text(x=35, y=50, labels="STOP", col="white", cex = 1);
rbox <- mbox(x0 = 14, x1 = 20, y0 = 47, y1 = 63);
polygon(x = rbox$x, y = rbox$y, lwd = 5, border = "black", col = "black");
text(x=17, y=55, labels="START", col="white", cex = 1, srt = 90);
arrows(x0=66, x1=40.5, y0=50, y1=50, lwd=2, length=0.10);
arrows(x0=45, x1=35, y0=60, y1=60, lwd=2, length=0.0);
arrows(x0=35, x1=35, y0=60, y1=67, lwd=2, length=0.0);
arrows(x0=35, x1=7, y0=67, y1=67, lwd=2, length=0.0);
arrows(x0=7, x1=7, y0=67, y1=71.5, lwd=2, length=0.1);
```

In each time step, pests feed in a random order, consuming the crop on their landscape cell.  Pests consume a maximum amount of the crop as specified by the `food_consume` argument, which takes a vector with as many elements as their are crops (i.e., if `crop_number = 2`, then `food_consume` has two elements, the first and second defining consumption of crops 1 and 2, respectively).
If crop amount on the landscape cell exceeds pest consumption ability, then pests consume their maximum amount, and this amount is removed from the landscape cell.
If crop amount is less than pest consumption ability, then pests consume whatever crop is left and crop amount is reduced to zero.
Pesticide consumption works identically to crop consumption, except that the amount of pesticide on a landscape cell is not decreased.
Pests simply consume an amount of pesticide as specified by the `pesticide_consume` argument, which also takes a vector with as many elements as their are pesticides.
Hence, each pest can potentially feed and be affected by the pesticide of their focal landscape cell. 

After interacting with their landscape cell, pests can move. 
Each pest visits a number of cells during movement, as is specified by the parameter `movement_bouts`. 
Individual movement bouts occur in a random order across pests.
During a movement bout, a pest can travel to any cell within a value defined by `movement_distance` from their current location, which could include their current location (i.e., moving zero distance).
Upon arrival to a cell, a pest can feed if they are of an appropriate feeding age and `feed_while_moving = TRUE`.
The pest also consumes pesticide if they are of the appropriate age and `pesticide_while_moving = TRUE`.
Having pests feed and consume pesticide in a random order while moving among landscape cells can model a population competing for food and encountering pesticides on a shorter time scale than an individual time step.

After all pests are done moving, pests reproduce.
Offspring production is possible for asexual, monoecious, or female pests.
Pest expected offspring number is defined by a fixed parameter if `reproduction_type = "lambda"`, or is calculated from the amount of food consumed if  `reproduction_type = "food_based"`.
The former requires specifying `lambda_value`, which becomes the rate parameter for sampling offspring number from a Poisson distribution.
The latter requires specifying a real value for `food_needed_repr`, which is the amount of food needed to produce one offspring.
For food-based reproduction, the total amount of food consumed is divided by `food_needed_repr`, then floored to determine offspring number.
Sexual reproduction requires a mate of reproductive age that is either monoecious or male, and within range of the reproducing focal pest (potential including the focal pest, if `selfing = TRUE`).
A potential mate is within range if it is within an integer number of cells from the focal pest, as defined by `mating_distance` (e.g., if `mating_distance = 0`, then mates must share a landscape cell).
All available potential mates sire offspring with equal probability, and reproducing pests are assumed to mate multiply (i.e., paternity is a fair raffle for all offspring).
If a carrying capacity on birth is set (`K_on_birth > 0`) and total offspring number in the population exceeds this capacity, then offspring are removed at random until they are  within carrying capacity.
An real value `immigration_rate` specifies the rate parameter for Poisson random sampling of the number of immigrants added to the population at the end of a time step.
Immigrants are initialised in the same way as pests were at the start of the simulation.
Hence, any spatial structure or evolution that occurs during the simulation does not affect immigrant locations, genomes, or traits.


Pest evolution {#evolution}
---------------------------------------------------

Pest genomes evolve in a complex and highly mechanistic way.
Offspring inherit genome values from their parent(s) with the possibility for mutation and recombination; offspring traits are then calculated from their newly initialised genomes.
For asexually and sexually reproducing pests, genomes are haploid and diploid, respectively. 
Asexually reproducing pests receive the full genomes of their parent, while sexually reproducing pests receive half of their alleles from each parent.
Each diploid parent contributes one half of their genome, effectively modelling a genome with a single paired chromosome.
Crossover occurs at each position of the genome with a probability of `crossover_pr`, so complete recombination is also possible if `crossover_pr = 0.5`.
For both haploids and diploids, each genome value then mutates independently with a probability of `mutation_pr`, which can be set to any real number between 0 and 1.
If a genome value mutates, then a new value is randomly sampled from a standard normal distribution.
If `mutation_type = 0`, then this new value replaces the old value, and if `mutation_type = 1`, then the new value is added to the old value.
After mutation, genome values are used to calculate trait values.

Evolution of the genetic architecture linking loci to traits can be constrained by disabling mutation genome values linking loci, internal nodes, and traits (i.e., 'network values' represented by arrows in Figure \@ref(fig:network)).
While mutation at loci (green circles in Figure \@ref(fig:network)) is always possible as long as `mutation_pr > 0`, the number of intermediary layers for which network values can mutate is constrained by `net_mu_layers`. 
If `net_mu_layers = 0`, then no network values can mutate, but higher integer values cause mutation to occur at network value layers from loci to traits (if `net_mu_dir = 1`) or traits to loci (if `net_mu_dir = 0`).
For example, if `net_mu_layers = 2` and `net_mu_dir = 1`, then the network values linking loci to the first internal node, and the first internal node to the second, can mutate (i.e., first two columns of arrows in \@ref(fig:network), but not those linking the second internal node to traits).
This allows pest traits to evolve with varying degrees of constraint on the covariance between traits.
Low `net_mu_layers` values model strong genetic constraints, while high values model high evolvability of trait covariances.

Finally, evolving and covarying traits can be used in place of fixed parameters described in pest ecology.
This is done by substituting `"Tj"` as argument input in place of a numeric value, where `j` represents the trait number.
For example, the argument `move_distance = "T1"` will make Trait 1 the movement distance for individuals. 
The argument `food_consume = c("T2", "T3")` will set Traits 2 and 3 to define the amount of food of types 1 and 2 that can be consumed by a pest, respectively.
Parameters that can be replaced include `move_distance`, `food_needed_surv`, `pesticide_tolerated_surv`, `food_needed_repr`, `pesticide_tolerated_repr`, `mating_distance`, `lambda_value`, `movement_bouts`, `metabolism`, `food_consume`, and `pesticide_consume`.
The resevol package can thereby simulate agricultural pests with complex and co-evolving traits, and potentially evolving trait covariances, under a range of possible pest life histories.

Simulation output {#output}
===================================================

Simulation output is large, so output is printed in two CSV files, both of which are created in the working directory.
The first file "population_data.csv" prints population level data over time, including population size, mean age, sex ratio, mean food and pesticide consumed of each type, mortality rate, and mean trait values. 
The second file "individuals.csv" prints all information, including full genomes and traits (columns), for every individual (rows) in the population.
The printing of individual level data is disabled by default.
It can be turned on for all time steps by setting `print_inds = TRUE`, but this should be done with caution because it can create extremely large files.
Instead, individual level data can be printed for only the final time step by setting `print_last = TRUE`.
Output produced by `run_farm_sim` is a list of two elements, which includes a vector of parameter values used in the simulation and the final state of the landscape as an array.


Example of individual-based simulations {#simulation}
===================================================

In resevol v0.3, the `run_farm_sim` function includes 68 arguments, which specify a wide range of possible simulation conditions affecting landscape and pest characteristics.
These arguments are explained the package documentation, and Supporting Information 2, which demonstrates an advanced case study with a custom landscape and complex pest genomes and life history.
Here we focus on a simple simulation with asexually reproducing pests that have three loci and two traits (Figure \@ref(fig:network)).
We use the the genome generated in `new_network` from [Section 2](#mine_gmatrix), in which traits 1 and 2 have variances of `r new_network[[6]][1,1]` and `r new_network[[6]][2,2]`, respectively, with a covariance of `r new_network[[6]][1,2]`.

Traits 1 and 2 will define the rate at which pests consume two separate pesticides, so we model a system in which there is a trade-off for pesticide susceptibility.
We use a simple $64 \times 64$ cell landscape with nine farms. 
Each farm grows the same crop and uses one of two randomly intialised pesticides, which are rotated every 16 time steps.
Hence, we can conceptualise 16 time steps as a single growing season.

In our example, each cell holds four crop units, all of which can potentially be consumed. 
Pests consume up to one unit of crop on their landscape cell per time step. 
Pest survival and reproduction is food-based, and pests need to consume one unit of crop by age two to survive and reproduce. 
Pests initialised at the start of the simulation are randomly assigned an age from 0-4 with equal probabilities.
Pests have a maximum age of four, and they feed in ages 0-2, move up to two cells in age three and four, and reproduce in age four.
Pests can consume pesticides in ages 0-2, and if they consume any pesticide, then they will die.
In each time step, 10 immigrants arrive.
We simulate 160 time steps (10 growing seasons) using the function below.

```{r, eval = TRUE}
sim <- run_farm_sim(mine_output = new_network, repro = "asexual", 
                    pesticide_number = 2, pesticide_init = "random", 
                    pesticide_consume = c("T1", "T2"), farms = 9,
                    pesticide_rotation_time = 16, pesticide_rotation_type = 3,
                    pesticide_tolerated_surv = 0, pesticide_per_cell = 1,
                    crop_rotation_time = 16, crop_number = 1, crop_per_cell = 4, 
                    food_consume = 1, reproduction_type = "food_based", 
                    food_needed_surv = 1, food_needed_repr = 1, max_age = 4, 
                    min_age_feed = 0, max_age_feed = 2, min_age_move = 3, 
                    max_age_move = 4, min_age_reproduce = 4, print_gens = FALSE,
                    max_age_reproduce = 4, age_pesticide_threshold = 2, 
                    rand_age = TRUE, move_distance = 2, immigration_rate = 10, 
                    time_steps = 160, print_last = TRUE, xdim = 64, ydim = 64);
```


Any arguments to `run_farm_sim` not included above are set to default values.
[Output files](#output) can be used to plot ecological and evolutionary dynamics of pests. 
Figure \@ref(fig:overtime)a shows the pest population change both over and within seasons.
Due to the specific parameter values chosen, clear patterns reflecting pest cohort emerge.
At the start of a season when the most crop is available, pests eat and abundance increases.
As less crop becomes available in a season, pest abundance decreases.
Mean food consumed varies over the course of a season caused by the varying frequency of pests in different life history stages (Figure \@ref(fig:overtime)c).
In the first 50 time steps, there is some consumption of pesticides 1 and 2 (Figure \@ref(fig:overtime)b), but both traits rapidly evolve to negative values making both pesticides ineffective (Figure \@ref(fig:overtime)d).
In this case, the trade-off between pesticide consumption is not strong enough to maintain susceptibility to either pesticide in the population.
Figure \@ref(fig:landscape) shows the location of pests on the landscape in the last time of the simulation (left panel), and how different pesticides are being applied on the landscape (right panel).
Because the number of crops and pesticides, the number and nature of traits, and the size of pest genomes all vary depending on simulation parameters, no plotting functions are introduced in the resevol package.
Instead, methods and code for producing plots such as those in Figures \@ref(fig:overtime) and \@ref(fig:landscape) are explained in Supporting Information 2.


```{r overtime, echo=FALSE, fig.width=8, fig.cap = "Agricultural pest ecological and evolutionary dynamics over 160 time steps from an individual-based simulation using the resevol R package. Panels show (a) pesticide abundance change, (b) mean of pesticides 1 and 2 consumed per pest, (c) mean food consumed per pest, and (d) mean values of evolving traits 1 and 2 over time. Traits 1 and 2 define how much of pesticides 1 and 2, respectively, a pest will consume. White and grey vertical stripes indicate seasons of a single crop and pesticide application."}
mbox <- function(x0, x1, y0, y1){
    xx <- seq(from=x0, to=x1, length.out = 100);
    yy <- seq(from=y0, to=y1, length.out = 100);
    xd <- c(rep(x0, 100), xx, rep(x1,100), rev(xx));
    yd <- c(yy, rep(y1,100), rev(yy), rep(y0, 100));
    return(list(x=xd, y=yd));
}
population_data <- read.csv("population_data.csv");
row_number      <- 161; # dim(population_data)[1];
time_step       <- population_data[["time_step"]][2:row_number];
population_size <- population_data[["population_size"]][2:row_number];
food_consumed   <- population_data[["mean_food_consumed"]][2:row_number];
p1_consumed     <- population_data[["mean_pesticide1_consumed"]][2:row_number];
p2_consumed     <- population_data[["mean_pesticide2_consumed"]][2:row_number];
trait1          <- population_data[["trait1_mean_value"]][2:row_number];
trait2          <- population_data[["trait2_mean_value"]][2:row_number];
season          <- seq(from = 0, to = 160, by = 16);
blocks          <- length(season) - 1;
par(mfrow = c(2, 2), mar = c(1, 5, 3, 1));
# Pest abundance plot
plot(x = time_step, y = population_size, type = "l", lwd = 2, xaxt = "n",
     xlab = "", ylab = "Pest abundance", cex.lab = 1, ylim = c(0, 4600),
     cex.axis = 1);
for(i in 1:blocks){
    rbox <- mbox(x0 = season[i], x1 = season[i + 1], y0 = -1000, y1 = 6000);
    if(i %% 2 == 0){
        polygon(x = rbox$x, y = rbox$y, lwd = 3, border = NA, 
                col = "grey90");
    }
}
text(x = 5, y = 4300, labels = "a", cex = 2);
points(x = time_step, y = population_size, type = "l", lwd = 2);
box();
# Pesticide consumed
plot(x = time_step, y = p1_consumed, type = "n", lwd = 2, xlab = "", xaxt = "n",
     ylab = "Mean pesticide consumed", cex.lab = 1, ylim = c(0, 0.35),
     cex.axis = 1);
for(i in 1:blocks){
    rbox <- mbox(x0 = season[i], x1 = season[i + 1], y0 = -1, y1 = 3);
    if(i %% 2 == 0){
        polygon(x = rbox$x, y = rbox$y, lwd = 3, border = NA, 
                col = "grey90");
    }
}
points(x = time_step, y = p1_consumed, type = "l", lwd = 2);
points(x = time_step, y = p2_consumed, type = "l", lwd = 2, col = "red",
       lty = "dashed");
legend(x = 158, y = 0.35, col = c("black", "red"), lty = c("solid", "dashed"),
       legend = c("Pesticide 1", "Pesticide 2"), cex = 1, lwd = 2, bg = "white",
       xjust = 1);
text(x = 5, y = 0.32, labels = "b", cex = 2);
box();
par(mar = c(4, 5, 0, 1));
# Pest food consumption plot
plot(x = time_step, y = food_consumed, type = "n", lwd = 2, xlab = "Time step",
     ylab = "Mean food consumed", cex.lab = 1, ylim = c(0, 2),
     yaxt = "n");
axis(side = 2, at = c(0, 0.5, 1, 1.5), cex.axis = 1);
for(i in 1:blocks){
    rbox <- mbox(x0 = season[i], x1 = season[i + 1], y0 = -1, y1 = 3);
    if(i %% 2 == 0){
      polygon(x = rbox$x, y = rbox$y, lwd = 2, border = NA, 
              col = "grey90");
    }
}
points(x = time_step, y = food_consumed, type = "l", lwd = 2);
text(x = 5, y = 0.2, labels = "c", cex = 2);
box();
# Pesticide traits
plot(x = time_step, y = trait1, type = "n", lwd = 2, xlab = "Time step",
     ylab = "Mean trait value", cex.lab = 1, ylim = c(-0.9, 0),
     yaxt = "n");
axis(side = 2, at = c(-0.8, -0.6, -0.4, -0.2), cex.axis = 1);
for(i in 1:blocks){
    rbox <- mbox(x0 = season[i], x1 = season[i + 1], y0 = -1, y1 = 3);
    if(i %% 2 == 0){
        polygon(x = rbox$x, y = rbox$y, lwd = 3, border = NA, 
                col = "grey90");
    }
}
points(x = time_step, y = trait1, type = "l", lwd = 2);
points(x = time_step, y = trait2, type = "l", lwd = 2, col = "red",
       lty = "dashed");
legend(x = 158, y = 0, col = c("black", "red"), lty = c("solid", "dashed"),
       legend = c("Trait 1", "Trait 2"), cex = 1, lwd = 2, xjust = 1, 
       bg = "white");
text(x = 5, y = -0.82, labels = "d", cex = 2);
box();
```



```{r landscape, echo=FALSE, fig.width=6.4, fig.height=3, fig.cap = "Locations of pests (black) across a landscape that includes nine farms (coloured blocks) in the last time step of a simulation using the resevol R package (left panel). The right panel shows which farms apply pesticide 1 (dark grey) and 2 (light grey)."}
last_time_step <- read.csv("last_time_step.csv", header = FALSE);
landscape      <- sim[[2]][,,1];
landscape_vals <- unique(as.vector(landscape));
reord_land     <- sample(landscape_vals, size = length(landscape_vals));
for(i in 1:dim(landscape)[1]){
    for(j in 1:dim(landscape)[2]){
        old_val         <- landscape[i, j];
        new_val         <- reord_land[old_val];
        landscape[i, j] <- new_val;
    }
}
for(i in 1:dim(last_time_step)[1]){
    xloc <- last_time_step[i, 3] + 1;
    yloc <- last_time_step[i, 4] + 1;
    landscape[xloc, yloc] <- 10;
}
land_cols      <- c(hcl.colors(9, "YlOrRd", rev = TRUE), "#000000");
par(mfrow = c(1, 2), mar = c(0, 0.1, 0, 0.1));
image(landscape, xaxt = "n", yaxt = "n", col = land_cols);
box();
pesticide_position <- sim[[2]][,,12];
pesticide_cols     <- c("grey20", "grey60");
image(pesticide_position, xaxt = "n", yaxt = "n", col = pesticide_cols);
box();
```


Availability {#availability}
===================================================

The resevol R package can be downloaded from CRAN (https://cran.r-project.org/package=resevol) or GitHub (https://bradduthie.github.io/resevol/). The package is open source under GNU Public License.

Conclusions {#conclusions}
===================================================



Acknowledgements {#acknowledgements}
===================================================

This software was developed as part of the project for Enhancing Diversity to Overcome Resistance Evolution (ENDORSE). The ENDORSE project is a joint Newton funded international partnership between the Biotechnology and Biological Sciences Research Council (BBSRC) in the UK and the S&#xE3;o Paulo Research Foundation (FAPESP) in Brazil under BBSRC award reference BB/S018956/1 and FAPESP award reference 2018/21089-3. ENDORSE is a partnership among Universidade Estadual Paulista (UNESP), the University of Stirling (UoS), and the Centre for Agricultural and Biosciences International (CABI).

References {#references}
===================================================


